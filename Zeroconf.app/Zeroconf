#!/usr/bin/env python3.7


# Copyright (c) 2020, Simon Peter <probono@puredarwin.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


import os, sys

try:
    from PyQt5 import QtWidgets, QtGui, QtCore
except:
    print("Could not import PyQt5. On FreeBSD, sudo pkg install py37-qt5-widgets")

# https://stackoverflow.com/a/377028
def which(program):

    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None


class ZeroconfService():

    def __init__(self, avahi_browse_line, browser):
        self.browser = browser
        parts = avahi_browse_line.split(";")
        self.interface = parts[1]
        self.ip_version = parts[2]
        self.name = parts[3] # .decode("utf-8", "strict")
        self.service_type = parts[4]
        self.domain = parts[5]
        self.hostname_with_domain = parts[6]
        self.address = parts[7]
        self.port = parts[8]
        self.txt = parts[9]
        self.url = "%s://%s:%s" % (self.service_type.split("_")[1].split("-")[0].replace(".", ""), self.hostname_with_domain, self.port)

    def __repr__(self):
        return "%s on %s:%s" % (self.service_type, self.hostname_with_domain, self.port)

    # Define here what we should do with detected services. This gets run whenever a service is added
    def handle(self):
        print("Handling %s", str(self))
        icon = 'applications-internet'
        if self.url.startswith("device"):
            icon = "computer"
        if self.url.startswith("ssh"):
            icon = "terminal"
        if self.url.startswith("sftp") or self.url.startswith("smb"):
            icon = "folder"
        if self.url.startswith("raop"):
            # AirPlay
            icon = "network-wireless"
        if self.url.startswith("pulse"):
            # PulseAudio
            icon = "audio-card"
        item = QtWidgets.QListWidgetItem(QtGui.QIcon.fromTheme(icon), self.url)
        self.browser.list_widget.addItem(item)


class ZeroconfServices():

    def __init__(self):
        self.services = []

    def add(self, service):
        print("Appending " + str(service))
        self.services.append(service)
        service.handle()

    def remove(self, avahi_browse_line):
        print("TODO: To be implemented: Remove the service from the list if certain criteria match")
        for service in self.services:
            print(service.service_type)
            print(service.hostname_with_domain)


class ZeroconfBrowser(object):

    def __init__(self):

        self.app = QtWidgets.QApplication(sys.argv)
        self.window = QtWidgets.QWidget()
        self.window.setWindowTitle('Connnect to Server')
        self.window.setMinimumWidth(500)
        self.window.setMinimumHeight(350)
        self.window.closeEvent = self.quit
        self.layout = QtWidgets.QVBoxLayout()
        self.list_widget = QtWidgets.QListWidget()
        self.list_widget.setAlternatingRowColors(True)
        self.list_widget.itemDoubleClicked.connect(self.onDoubleClicked)
        self.layout.addWidget(self.list_widget)
        self.window.setLayout(self.layout)
        self.window.show()

        self.services = ZeroconfServices()
        self.ext_process = QtCore.QProcess()
        self.long_running_function()

        sys.exit(self.app.exec_())

    def quit(self, event):
        sys.exit(0)

    def onDoubleClicked(self):
        print("Double clicked")
        row = self.list_widget.selectedIndexes()[0].row()
        print(self.services.services[row].url)

        if self.services.services[row].url.startswith("http"):

            # Find out the browser
            # TODO: Give preference to the default browser the user may have set in the system.
            # user@FreeBSD$  xdg-settings get default-web-browser
            # userapp-Firefox-59CXP0.desktop
            # Then no one knows where that file actually is, nor what it Exec= line contains. xdg is so convoluted!
            # user@FreeBSD$ LANG=C x-www-browser
            # bash: x-www-browser: command not found
            #
            # browser_candidates = [os.environ.get("BROWSER"), "x-www-browser", "chrome", "chromium-browser", "google-chrome", "firefox", "iceweasel", "seamonkey", "mozilla", "epiphany", "konqueror"]
            # for browser_candidate in browser_candidates:
            #     if browser_candidate != None:
            #         if which(browser_candidate) != None:
            #             browser = browser_candidate
            #             print("Using as browser: %s" % browser)
            #             break

            # Launch the browser
            proc = QtCore.QProcess()
            args = [self.services.services[row].url]
            try:
                proc.startDetached("xdg-open", args)
            except:
                print("Cannot launch browser")
                return


        elif self.services.services[row].url.startswith("sftp") or self.services.services[row].url.startswith("ntp"):
            # https://github.com/xvlvx0/AutoMounter
            reply = QtWidgets.QMessageBox.information(
                self.window,
                "To be implemented",
                "%s\nshould be mounted using sshfs.\nSee https://github.com/xvlvx0/AutoMounter for inspiration.\nPull requests welcome!" % self.services.services[row].url,
                QtWidgets.QMessageBox.Yes
            )

        else:
            reply = QtWidgets.QMessageBox.information(
                self.window,
                "To be implemented",
                "Something needs to be done here with\n%s\nPull requests welcome!" % self.services.services[row].url,
                QtWidgets.QMessageBox.Yes
            )

    def long_running_function(self):
        self.ext_process.finished.connect(self.onProcessFinished)
        self.ext_process.setProgram("avahi-browse")
        self.ext_process.setArguments(["-arlp"])

        try:
            pid = self.ext_process.start()
            print("avahi-browse started")
        except:
            self.showErrorPage("avahi-browse cannot be launched.")
            return  # Stop doing anything here


        if self.ext_process.waitForStarted(-1):
            while True:
                QtWidgets.QApplication.processEvents()  # Important trick so that the app stays responsive without the need for threading!
                while self.ext_process.canReadLine():
                    # This is a really crude attempt to read line-wise. FIXME: Do better
                    line = str(self.ext_process.readLine())
                    self.processLine(line)

        print("ERROR: We should never reach this!")

    def onProcessFinished(self):
        print("onProcessFinished called")

    def processLine(self, line):
        line = str(line).replace("b'", "").replace("\\n'", "")
        print(line)
        if line.startswith("="):
            s = ZeroconfService(line, self)
            self.services.add(s)
        if line.startswith("-"):
            s = ZeroconfService(line, self)
            self.services.remove(line)


if __name__ == "__main__":

    zb = ZeroconfBrowser()